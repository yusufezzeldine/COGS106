# -*- coding: utf-8 -*-
"""Final Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kD2qLy9A0VWxs8GShsm4HTX8YLADLRGE
"""

import unittest
import scipy.stats
import numpy as np
import random as rnd
import math as m

class Metropolis:

  def __init__(self,logTarget,initialState):
    self.__logTarget = logTarget
    self.__initialState = initialState
    self.samples = []

  def __accept(self,proposal):
    rand = rnd.uniform(0,1)
    if proposal > rand:
      return True
    else:
      return False

  def adapt(self):
    sd , rk = 1 , 0
    while rk != 0.4:
      sd_new = sd + 1
      rk = 0.4/((sd_new/sd)**(1/1.1))
      sd = sd_new
    return sd_new

  def sample(self,n):
    state = self.__initialState
    for i in range(0,n):
      proposal = np.random.normal(state,self.adapt())
      pr = min(1,m.exp(proposal/state))
      yesno = self.__accept(pr)
      if yesno:
        state = proposal
      self.samples.append(state)

  def summary(self):
    return {"Mean" : sum(self.__samples)/len(self.__samples), "Interval" : scipy.stats.norm.interval(alpha=0.95, loc=np.mean(self.__samples), scale=scipy.stats.sem(self.__samples))}

import scipy as spi
import matplotlib.pyplot as plt

class SignalDetection:
    
    def __init__(self, hits, misses, false_alarms, correct_rejections):
        self.hits = hits
        self.misses = misses
        self.false_alarms = false_alarms
        self.correct_rejections = correct_rejections
    
    def H(self):
        return (self.hits / (self.hits + self.misses))

    def FA(self):
        return (self.false_alarms / (self.false_alarms + self.correct_rejections))

    def d_prime(self):
        return (spi.stats.norm.ppf(self.H()) - spi.stats.norm.ppf(self.FA()))

    def criterion(self):
        return ((-0.5) * (spi.stats.norm.ppf(self.H()) + spi.stats.norm.ppf(self.FA())))
    
    def __add__(self, other):
        return SignalDetection(self.hits + other.hits, self.misses + other.misses, self.false_alarms + other.false_alarms, self.correct_rejections + other.correct_rejections)
    
    def __mul__(self, scalar):
        return SignalDetection(self.hits * scalar, self.misses * scalar, self.false_alarms * scalar, self.correct_rejections * scalar)
    
    @staticmethod
    def simulate(dprime, criteriaList, signalCount, noiseCount):
      sdtList = []
      for i in range(len(criteriaList)):
          k = criteriaList[i] + (dprime/2)
          hits, falseAlarms = np.random.binomial(n=[signalCount, noiseCount], p=[1 - spi.stats.norm.cdf(k - dprime),1 - spi.stats.norm.cdf(k)])
          misses, correctRejections = signalCount - hits, noiseCount - falseAlarms
          sdtList.append(SignalDetection(hits, misses, falseAlarms, correctRejections))
      
      return sdtList

    @staticmethod
    def plot_roc(sdtList):
        plt.xlim([0,1])
        plt.ylim([0,1])
        plt.xlabel("False Alarm Rate")
        plt.ylabel("Hit Rate")
        plt.title("Receiver Operating Characteristic Curve")
        if isinstance(sdtList, list):
            for i in range(len(sdtList)):
                s = sdtList[i]
                plt.plot(s.FA(), s.H(), 'o', color = 'black', markersize = 10)
        else:
            plt.plot(sdtList.FA(), sdtList.H(), 'o', color = 'black', markersize = 10)
        x, y = np.linspace(0,1,100), np.linspace(0,1,100)
        plt.plot(x,y, '--', color = 'black')
        plt.grid()

    def plot_sdt(self):
        noise_x = np.arange(-4, 4, 0.1)
        noise_y = spi.stats.norm.pdf(noise_x, 0, 1)
        signal_x = np.arange(-4, 4, 0.1)
        signal_y = spi.stats.norm.pdf(noise_x, self.d_prime(), 1)
        plt.plot(noise_x, noise_y, label = "Noise", color = 'blue')
        plt.plot(signal_x, signal_y, label = "Signal", color = 'green')
        plt.axvline(x = ((self.d_prime() / 2) + self.criterion()), label = "k", color = 'r', linestyle = '--')
        x_distance = [0, self.d_prime()]
        y_distance = [0.4, 0.4]
        plt.plot(x_distance, y_distance, '--', label = "Distance", color = 'black')
        plt.plot(0,0, 'o', label = '0', color = 'blue')
        plt.plot(self.d_prime(), 0, 'o', label = 'D\'', color = 'green')
        plt.title("Signal Detection Theory Curve")
        plt.xlabel("Response")
        plt.ylabel("Probability")
        plt.legend()
        plt.show()

    def nLogLikelihood(self, hit_rate, false_alarm_rate):
        return -((self.hits * np.log(hit_rate)) + (self.misses * np.log(1-hit_rate)) + (self.false_alarms * np.log(false_alarm_rate)) + (self.correct_rejections * np.log(1-false_alarm_rate)))

    @staticmethod
    def rocCurve(falseAlarmRate, a):
        return spi.stats.norm.cdf(a + spi.stats.norm.ppf((falseAlarmRate)))
    
    @staticmethod
    def fit_roc(sdtList):
        SignalDetection.plot_roc(sdtList)
        a = 0
        minimize = spi.optimize.minimize(fun = SignalDetection.rocLoss, x0 = a, method = 'nelder-mead', args = (sdtList))
        losscurve = []
        for i in range(0,100,1):
          losscurve.append((SignalDetection.rocCurve(i/100, float(minimize.x))))
        plt.plot(np.linspace(0,1,100), losscurve, '-', color='red')
        aHat = minimize.x
        return float(aHat)

    @staticmethod
    def rocLoss(a, sdtList):
        L = []
        for i in range(len(sdtList)):
            s = sdtList[i]
            predicted_hit_rate = s.rocCurve(s.FA(), a)
            L.append(s.nLogLikelihood(predicted_hit_rate, s.FA()))
        return sum(L)

def fit_roc_bayesian(sdtList):

    # Define the log-likelihood function to optimize
    def loglik(a):
        return -SignalDetection.rocLoss(a, sdtList) + scipy.stats.norm.logpdf(a, loc = 0, scale = 10)

    # Create a Metropolis sampler object and adapt it to the target distribution
    sampler = Metropolis(logTarget = loglik, initialState = 0)
    # sampler = sampler.adapt(blockLengths = [2000]*3)

    # Sample from the target distribution
    sampler = sampler.sample(n = 4000)

    # Compute the summary statistics of the samples
    result  = sampler.summary()

    # Print the estimated value of the parameter a and its credible interval
    print(f"Estimated a: {result['mean']} ({result['c025']}, {result['c975']})")

    # Create a mosaic plot with four subplots
    fig, axes = plt.subplot_mosaic(
        [["ROC curve", "ROC curve", "traceplot"],
         ["ROC curve", "ROC curve", "histogram"]],
        constrained_layout = True
    )

    # Plot the ROC curve of the SDT data
    plt.sca(axes["ROC curve"])
    SignalDetection.plot_roc(sdtList = sdtList)

    # Compute the ROC curve for the estimated value of a and plot it
    xaxis = np.arange(start = 0.00,
                      stop  = 1.00,
                      step  = 0.01)

    plt.plot(xaxis, SignalDetection.rocCurve(xaxis, result['mean']), 'r-')

    # Shade the area between the lower and upper bounds of the credible interval
    plt.fill_between(x  = xaxis,
                     y1 = SignalDetection.rocCurve(xaxis, result['c025']),
                     y2 = SignalDetection.rocCurve(xaxis, result['c975']),
                     facecolor = 'r',
                     alpha     = 0.1)

    # Plot the trace of the sampler
    plt.sca(axes["traceplot"])
    plt.plot(sampler.samples)
    plt.xlabel('iteration')
    plt.ylabel('a')
    plt.title('Trace plot')

    # Plot the histogram of the samples
    plt.sca(axes["histogram"])
    plt.hist(sampler.samples,
             bins    = 51,
             density = True)
    plt.xlabel('a')
    plt.ylabel('density')
    plt.title('Histogram')

    # Show the plot
    plt.show()

# Define the number of SDT trials and generate a simulated dataset
sdtList = SignalDetection.simulate(dprime       = 1,
                                   criteriaList = [-1, 0, 1],
                                   signalCount  = 40,
                                   noiseCount   = 40)

# Fit the ROC curve to the simulated dataset
fit_roc_bayesian(sdtList)