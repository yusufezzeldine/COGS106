# -*- coding: utf-8 -*-
"""COGS106_A3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tJiCr2quO2g-QS2LFFVaWYthL84t27MH
"""

#Creating a non-smelly version of the Signal Detection Class

from scipy.special import ndtri

class SignalDetection:
  def __init__(self,hits,misses,false_alarms,correct_rejections):
    # Define variables
    self.hits = hits
    self.misses = misses
    self.false_alarms = false_alarms
    self.correct_rejections = correct_rejections
  
  def hit_rate(self):
    # Calculates the Hit Rate
    return (self.hits / (self.hits + self.misses))

  def false_alarm_rate(self):
    # Calculates the False Alarm Rate 
    return (self.false_alarms / (self.false_alarms + self.correct_rejections))
  
  def d_prime(self):
    # Calculates the d-Prime value
    return (ndtri(self.hit_rate()) - ndtri(self.false_alarm_rate()))
  
  def criterion(self):
    # Calculates the Criterion value
    return (-0.5 * (ndtri(self.hit_rate()) + ndtri(self.false_alarm_rate())))

## Testing if the class works correctly, and if the objects can be corrupted

import unittest
import numpy as np
import matplotlib.pyplot as plt

class TestSignalDetection(unittest.TestCase):
    def test_d_prime_zero(self):
        sd   = SignalDetection(15, 5, 15, 5)
        expected = 0
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_d_prime_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        expected = -0.421142647060282
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_criterion_zero(self):
        sd   = SignalDetection(5, 5, 5, 5)
        # Calculate expected criterion        
        expected = 0
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_criterion_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        # Calculate expected criterion        
        expected = -0.463918426665941
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_object_corruption(self):
        sd   = SignalDetection(15, 5, 15, 5)
        expected = sd.d_prime()
        sd.hits = 1824
        sd.misses = 1248
        sd.false_alarms = 1248
        sd.correct_rejections = 2142
        obtained = sd.d_prime()
        # Compare original and corrupted d-prime
        self.assertAlmostEqual(obtained, expected, places=6)

if __name__ == '__main__':
    unittest.main(argv=['ignored'], exit=False)

#Fixing the Signal Detection Class to prevent objects from being corrupted

class SignalDetection:
  def __init__(self,hits,misses,false_alarms,correct_rejections):
    # Define variables
    self.__hits = hits
    self.__misses = misses
    self.__false_alarms = false_alarms
    self.__correct_rejections = correct_rejections
  
  def hit_rate(self):
    # Calculates the Hit Rate
    return (self.__hits / (self.__hits + self.__misses))

  def false_alarm_rate(self):
    # Calculates the False Alarm Rate 
    return (self.__false_alarms / (self.__false_alarms + self.__correct_rejections))
  
  def d_prime(self):
    # Calculates the d-Prime value
    return (ndtri(self.hit_rate()) - ndtri(self.false_alarm_rate()))
  
  def criterion(self):
    # Calculates the Criterion value
    return (-0.5 * (ndtri(self.hit_rate()) + ndtri(self.false_alarm_rate())))

## Running the test again to see if the objects are non-corruptable now

import unittest
import numpy as np
import matplotlib.pyplot as plt

class TestSignalDetection(unittest.TestCase):
    def test_d_prime_zero(self):
        sd   = SignalDetection(15, 5, 15, 5)
        expected = 0
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_d_prime_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        expected = -0.421142647060282
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_criterion_zero(self):
        sd   = SignalDetection(5, 5, 5, 5)
        # Calculate expected criterion        
        expected = 0
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_criterion_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        # Calculate expected criterion        
        expected = -0.463918426665941
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=6)
    def test_object_corruption(self):
        sd   = SignalDetection(15, 5, 15, 5)
        expected = sd.d_prime()
        sd.__hits = 1824
        sd.__misses = 1248
        sd.__false_alarms = 1248
        sd.__correct_rejections = 2142
        obtained = sd.d_prime()
        # Compare original and corrupted d-prime
        self.assertAlmostEqual(obtained, expected, places=6)

if __name__ == '__main__':
    unittest.main(argv=['ignored'], exit=False)

# Overload + and * operators for SignalDetection class 

class SignalDetection:
  def __init__(self,hits,misses,false_alarms,correct_rejections):
    # Define variables
    self.__hits = hits
    self.__misses = misses
    self.__false_alarms = false_alarms
    self.__correct_rejections = correct_rejections
  
  def hit_rate(self):
    # Calculates the Hit Rate
    return (self.__hits / (self.__hits + self.__misses))

  def false_alarm_rate(self):
    # Calculates the False Alarm Rate 
    return (self.__false_alarms / (self.__false_alarms + self.__correct_rejections))
  
  def d_prime(self):
    # Calculates the d-Prime value
    return (ndtri(self.hit_rate()) - ndtri(self.false_alarm_rate()))
  
  def criterion(self):
    # Calculates the Criterion value
    return (-0.5 * (ndtri(self.hit_rate()) + ndtri(self.false_alarm_rate())))

  def __add__(self, other):
    return SignalDetection(self.__hits + other.__hits, self.__misses + other.__misses, self.__false_alarms + other.__false_alarms, self.__correct_rejections + other.__correct_rejections)

  def __mul__(self, scalar):
    return SignalDetection(self.__hits * scalar, self.__misses * scalar, self.__false_alarms * scalar, self.__correct_rejections * scalar)

# Updated unit test to include + and * operators 
import unittest

class TestSignalDetection(unittest.TestCase):

    def test_d_prime_zero(self):
        sd   = SignalDetection(15, 5, 15, 5)
        expected = 0
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_d_prime_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        expected = -0.421142647060282
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_criterion_zero(self):
        sd   = SignalDetection(5, 5, 5, 5)
        # Calculate expected criterion
        expected = 0
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_criterion_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        # Calculate expected criterion
        expected = -0.463918426665941
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_addition(self):
        sd = SignalDetection(1, 1, 2, 1) + SignalDetection(2, 1, 1, 3)
        expected = SignalDetection(3, 2, 3, 4).criterion()
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertEqual(obtained, expected)

    def test_multiplication(self):
        sd = SignalDetection(1, 2, 3, 1) * 4
        expected = SignalDetection(4, 8, 12, 4).criterion()
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertEqual(obtained, expected)

if __name__ == '__main__':
    unittest.main(argv=['ignored'], exit=False)

# Introduce a SignalDetection class that handles lists of value sets instead of just one set, and a method to plot an ROC curve

class SignalDetection:
  def __init__(self,hits,misses,false_alarms,correct_rejections):
    # Define the lists of variables
    self.__hits = hits
    self.__misses = misses
    self.__false_alarms = false_alarms
    self.__correct_rejections = correct_rejections
  
  def hit_rate(self):
    # Calculates the Hit Rates for all pairs of values
    if (type(self.__hits) is int) and (type(self.__misses) is int):
      return (self.__hits / (self.__hits + self.__misses))
    elif len(self.__hits) == len(self.__misses):
      self.__hit_rates = []
      for i in range(0,len(self.__hits)):
        self.__hit_rates.append((self.__hits[i] / (self.__hits[i] + self.__misses[i])))
      return self.__hit_rates
    else:
      return "Mismatched array sizes for hits and misses"

  def false_alarm_rate(self):
    # Calculates the False Alarm Rates for all pairs of values
    if (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      return (self.__false_alarms / (self.__false_alarms + self.__correct_rejections))
    elif len(self.__false_alarms) == len(self.__correct_rejections):
      self.__false_alarm_rates = []
      for i in range(0,len(self.__false_alarms)):
        self.__false_alarm_rates.append((self.__false_alarms[i] / (self.__false_alarms[i] + self.__correct_rejections[i])))
      return self.__false_alarm_rates
    else:
      return "Mismatched array sizes for false alarms and correct rejections"
  
  def d_prime(self):
    # Calculates the d-Prime values for all pairs of values
    if (type(self.__hits) is int) and (type(self.__misses) is int) and (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      return (ndtri(self.hit_rate()) - ndtri(self.false_alarm_rate()))
    elif len(self.__hits) == len(self.__misses) == len(self.__false_alarms) == len(self.__correct_rejections):
      self.__d_primes = []
      for i in range(0,len(self.__hits)):
        self.__d_primes.append((ndtri(self.hit_rate()[i]) - ndtri(self.false_alarm_rate()[i])))
      return self.__d_primes
    else:
      return "Mismatched array sizes for the provided lists of values"
  
  def criterion(self):
    # Calculates the criterion values for all pairs of values
    if (type(self.__hits) is int) and (type(self.__misses) is int) and (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      return (-0.5 * (ndtri(self.hit_rate()) + ndtri(self.false_alarm_rate())))
    elif len(self.__hits) == len(self.__misses) == len(self.__false_alarms) == len(self.__correct_rejections):
      self.__criterions = []
      for i in range(0,len(self.__hits)):
        self.__criterions.append((-0.5 * (ndtri(self.hit_rate()[i]) + ndtri(self.false_alarm_rate()[i]))))
      return self.__criterions
    else:
      return "Mismatched array sizes for the provided lists of values"

  def __add__(self, other):
    return SignalDetection(self.__hits + other.__hits, self.__misses + other.__misses, self.__false_alarms + other.__false_alarms, self.__correct_rejections + other.__correct_rejections)

  def __mul__(self, scalar):
    return SignalDetection(self.__hits * scalar, self.__misses * scalar, self.__false_alarms * scalar, self.__correct_rejections * scalar)
  
  def plot_ROC(self):
    # Generates an ROC plot based on the list of provided values
    if (type(self.__hits) is int) and (type(self.__misses) is int) and (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      plt.plot([0,self.false_alarm_rate(),1],[0,self.hit_rate(),1])
      plt.xlabel("False Positive")
      plt.ylabel("True Positive")
      plt.show()
    elif len(self.__hits) == len(self.__misses) == len(self.__false_alarms) == len(self.__correct_rejections):
      self.__false_alarm_rates = [0] + self.false_alarm_rate() + [1]
      self.__hit_rates = [0] + self.hit_rate() + [1]
      plt.plot(self.__false_alarm_rates,self.__hit_rates)
      plt.xlabel("False Positive")
      plt.ylabel("True Positive")
      plt.show()
    else:
      return "Mismatched array sizes for the provided lists of values"

sd = SignalDetection([10,40,35],[4,9,3],[2,5,7],[9,17,11])
sd.plot_ROC()

# Introduce a SignalDetection class that adds a method to create an SDT plot
from scipy import stats

class SignalDetection:
  def __init__(self,hits,misses,false_alarms,correct_rejections):
    # Define the lists of variables
    self.__hits = hits
    self.__misses = misses
    self.__false_alarms = false_alarms
    self.__correct_rejections = correct_rejections
  
  def hit_rate(self):
    # Calculates the Hit Rates for all pairs of values
    if (type(self.__hits) is int) and (type(self.__misses) is int):
      return (self.__hits / (self.__hits + self.__misses))
    elif len(self.__hits) == len(self.__misses):
      self.__hit_rates = []
      for i in range(0,len(self.__hits)):
        self.__hit_rates.append((self.__hits[i] / (self.__hits[i] + self.__misses[i])))
      return self.__hit_rates
    else:
      return "Mismatched array sizes for hits and misses"

  def false_alarm_rate(self):
    # Calculates the False Alarm Rates for all pairs of values
    if (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      return (self.__false_alarms / (self.__false_alarms + self.__correct_rejections))
    elif len(self.__false_alarms) == len(self.__correct_rejections):
      self.__false_alarm_rates = []
      for i in range(0,len(self.__false_alarms)):
        self.__false_alarm_rates.append((self.__false_alarms[i] / (self.__false_alarms[i] + self.__correct_rejections[i])))
      return self.__false_alarm_rates
    else:
      return "Mismatched array sizes for false alarms and correct rejections"
  
  def d_prime(self):
    # Calculates the d-Prime values for all pairs of values
    if (type(self.__hits) is int) and (type(self.__misses) is int) and (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      return (ndtri(self.hit_rate()) - ndtri(self.false_alarm_rate()))
    elif len(self.__hits) == len(self.__misses) == len(self.__false_alarms) == len(self.__correct_rejections):
      self.__d_primes = []
      for i in range(0,len(self.__hits)):
        self.__d_primes.append((ndtri(self.hit_rate()[i]) - ndtri(self.false_alarm_rate()[i])))
      return self.__d_primes
    else:
      return "Mismatched array sizes for the provided lists of values"
  
  def criterion(self):
    # Calculates the criterion values for all pairs of values
    if (type(self.__hits) is int) and (type(self.__misses) is int) and (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      return (-0.5 * (ndtri(self.hit_rate()) + ndtri(self.false_alarm_rate())))
    elif len(self.__hits) == len(self.__misses) == len(self.__false_alarms) == len(self.__correct_rejections):
      self.__criterions = []
      for i in range(0,len(self.__hits)):
        self.__criterions.append((-0.5 * (ndtri(self.hit_rate()[i]) + ndtri(self.false_alarm_rate()[i]))))
      return self.__criterions
    else:
      return "Mismatched array sizes for the provided lists of values"

  def __add__(self, other):
    return SignalDetection(self.__hits + other.__hits, self.__misses + other.__misses, self.__false_alarms + other.__false_alarms, self.__correct_rejections + other.__correct_rejections)

  def __mul__(self, scalar):
    return SignalDetection(self.__hits * scalar, self.__misses * scalar, self.__false_alarms * scalar, self.__correct_rejections * scalar)
  
  def plot_ROC(self):
    # Generates an ROC plot based on the list of provided values
    if (type(self.__hits) is int) and (type(self.__misses) is int) and (type(self.__false_alarms) is int) and (type(self.__correct_rejections) is int):
      plt.plot([0,self.false_alarm_rate(),1],[0,self.hit_rate(),1])
      plt.xlabel("False Positive")
      plt.ylabel("True Positive")
      plt.show()
    elif len(self.__hits) == len(self.__misses) == len(self.__false_alarms) == len(self.__correct_rejections):
      self.__false_alarm_rates = [0] + self.false_alarm_rate() + [1]
      self.__hit_rates = [0] + self.hit_rate() + [1]
      plt.plot(self.__false_alarm_rates,self.__hit_rates)
      plt.xlabel("False Positive")
      plt.ylabel("True Positive")
      plt.show()
    else:
      return "Mismatched array sizes for the provided lists of values"
  def plot_SDT(self):
    # Generates an SDT graph based on the provided values
    x = np.linspace(-10,10,100)
    plt.plot(x,stats.norm(0,1).pdf(x))
    plt.plot(x,stats.norm(self.d_prime(),1).pdf(x))
    plt.ylabel("Probability")
    plt.show()

sd = SignalDetection(10,4,2,9)
sd.plot_SDT()